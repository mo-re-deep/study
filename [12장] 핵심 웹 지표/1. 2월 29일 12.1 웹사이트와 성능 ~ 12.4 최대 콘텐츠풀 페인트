12장. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 12.1 웹사이트와 성능

- **웹사이트의 성능이 영향을 미치는 요소**
    
    (출처 : 2019년 미국 디지털 마케팅 에이전시 Protent의 조사)
    
    - 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율(실제 구매로 이어지는 고객의 비율)이 2.5배 더 높다.
    - 0~5초의 범위에서, 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다. 즉, 5초 이상 느려지면 전환율은 20% 가까이 떨어진다.
    - 페이지 로드 시간이 0~2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다.
    
- **성능에 대한 사용자의 의견**
    - 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝혔으며,
    - 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요없다고 밝혔다.
    
- **웹사이트의 성능에 관한 통계**
    
    (출처 : 구글)
    
    - 전체 웹페이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다. (한 페이지를 로딩하는 데 50회 미만의 요청이 발생해야한다.)
    - 평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸린다.
    - 인간의 뇌와 신경계를 분석한 결과 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가한다.
    
- 현재 : 모바일 기기의 성능 향상, 빨라진 네트워크 속도, IT서비스 업체가 하는 서버/통신 등의 물리 장비의 발전 ⇒ 그럼에도 불구하고 여전히 느리고 너무 많은 요소 때문에 비대해졌다.
    
    

![2022080700095_3.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/b45f5aa7-9f0b-46b0-80f5-dd962af7f0da/2022080700095_3.png)

![스크린샷 2024-02-27 오후 9.34.30.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/b410708f-c351-46b5-8f1e-eaf615f66b28/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.34.30.png)

<aside>
🌐 1998년 네이버에 비해 현재 네이버는 화려하고 커졌고 무거워졌다. 현재 네이버 페이지 완성을 위해 약 245회 이상의 요청을 하고 리소스 또한 7.5mb를 사용하고 있다.

</aside>

- 웹사이트 개발자라면 반드시 웹사이트의 성능에도 주의를 기울여야 한다.

## 12.2 핵심 웹 지표란?

- **핵심 웹 지표 (Core Web Vital)**
    
    : 구글에서 만든 지표로, 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어다.
    
    - 최대 콘텐츠풀 페인트(LCP : Largest Contentful Paint)
    - 최초 입력 지연(FID : First Input Delay)
    - 누적 레이아웃 이동(CLS : Cumulative Layout Shift)
    
    (아래는 핵심 지표는 아니지만 특정 문제를 진단하는 데 사용되는 지표)
    
    - 최초 바이트까지의 시간(TTFB : Time To First Byte)
    - 최초 콘텐츠풀 시간(FCP : First Contentful Paint)

## 12.3 최대 콘텐츠풀 페인트(LCP: Largest Contentful Paint)

- 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간을 말한다.
    
    (뷰포트 : 사용자에게 현재 노출되는 화면을 의미하고, 노출되는 기기에 따라 크기가 다르다.)
    
    - <img>
    - <svg> 내부의 <image>
    - poster 속성을 사용하는 <video>
    - url()을 통해 불러온 배경 이미지가 있는 요소
    - 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소 (<p>, <div> 등)
- 실제 웹페이지가 로딩이 완료되는 것은 DOMContentLoaded 이벤트가 호출되는 시간이지만 이는 사용자가 인식하는 로딩과 다르다. 사용자는 뷰포트 영역에 보이는 부분만 보이면 로딩이 완료됐다고 느끼고, 이러한 속도를 객관적으로 판단하기 위한 지표로 만들어진 것이 최대 콘텐츠풀이다.

![스크린샷 2024-02-28 오전 9.06.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/d4c5e89b-66f0-4a3f-ace3-11f7e15d1394/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-28_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.06.23.png)

![스크린샷 2024-02-28 오전 9.06.37.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/62e9dbf8-d81a-4ec3-ab73-0c910d99114c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-28_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.06.37.png)

![스크린샷 2024-02-28 오전 9.06.28.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/16dd6db2-2d4e-475e-a9c9-a1f68b2d88ed/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-28_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.06.28.png)

- 네이버 스포츠의 최대 콘텐츠풀 페인트의 변화 과정 설명
    1. 최초에 헤더가 가장 먼저 노출됐다. ⇒ 최대 콘텐츠풀 페인트 : 헤더
    2. 헤더보다 크기가 큰 바둑판 메뉴가 노출됐다. ⇒ 최대 콘텐츠풀 페인트 : 바둑판 메뉴 
    3. 먼저 사진영역이 나오고 이미지로딩까지 완료됐다. ⇒ 최대 콘텐츠풀 페인트 지표가 기록된다.

## 12.3.4 기준점수

![unnamed.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/1c677c23-78b0-45f2-aa22-127e69bdebd0/unnamed.png)

최대 컨텐츠풀 페인트에서 해당 지표가 2.5초 내로 응답이 오면 좋은 점수, 4초 이내로 응답이 오면 보통, 그 이상은 나쁨으로 판단된다.

## 12.3.5 개선방안

- 최대 콘텐츠풀 페인트의 점수를 높일 수 있는 방법
    - 뷰포트 최대 영역, 즉 최대 콘텐츠풀 페인트 예상 영역을 문자열로 채운다.
        - 이미지는 최적화를 하더라도 추가적인 리소스 다운로드가 필요해서 텍스트 노출이 훨씬 빠르다.
    - 이미지 노출하는 방법
        
        ```tsx
        <!-- 1) img -->
        <img src="lcp.jpg" ... />
        
        <!-- 2) svg -->
        <svg xmlns="http://www.w3.org/1000/svg">
        	<image href="lcp.jpg" />
        </svg>
        
        <!-- 3)(비디오의 경우) video.poster -->
        <video poster="lcp.jpg"></video>
        
        <!-- 4) background-image: url() -->
        <div style="background-image: url(lcp.jpg)"> ... </div>
        ```
        
        - 위 코드를 브라우저에서 실행했을 때 페이지가 완성되는 순서
            
            ![LCP_result.webp](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/ac3a60db-0505-443a-b388-671fbb504065/LCP_result.webp)
            
        - 페이지가 완성되는 순서를 시간 단위로 본 그래프
            
            ![LCP_progress.webp](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/8c2fe457-e095-416a-9cf6-195b229b2fba/LCP_progress.webp)
            
        - **<img>**
            
            : <img> 내부의 리소스는 HTML 파싱이 미처 완료되지 않더라도 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 병렬적으로 리소스가 다운로드된다.
            
            <aside>
            👀 **프리로드 스캐너** : 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아서 로딩하는 브라우저 기능 (HTML을 파싱하는 단계를 차단하지 않음)
            
            </aside>
            
            ![KakaoTalk_Photo_2024-02-28-12-12-48 001.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/3127e405-cde9-48cd-ac28-3e94cdbbb8dd/KakaoTalk_Photo_2024-02-28-12-12-48_001.jpeg)
            
        
        - **<svg> 내부의 <img>**
            
            : <svg> 내부의 <img>가 로딩이 완료되기 전까지는 최대 콘텐츠풀 페인트가 완료되지 않는다. 또한, 모든 리소스를 다 불러온 이후에 이미지를 불러온다. 
            
            ![KakaoTalk_Photo_2024-02-28-12-12-48 002.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/fee1ea62-01b4-4d3d-9626-8ee9ede63af5/KakaoTalk_Photo_2024-02-28-12-12-48_002.jpeg)
            
        
        - **<video>의 poster**
            
            : poster는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소다. 
            
            : 프리로드 스캐너에 의해 조기에 발견되어 병렬적으로 리소스가 다운로드된다.
            
            : 만약 poster가 없으면 video를 실제로 로딩한 후 첫번째 프레임으로 대체되기때문에 최대 콘텐츠풀 페인트에 영향을 받을 것 같으면 poster를 최대한 넣어주는 것이 좋다.
            
        
        - **background-image: url()**
            
            : CSS에 있는 리소스는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문에 항상 느리다. 
            
    
    - 그 밖에 조심해야할 것들
        - 이미지는 가능한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋다.
        - loading=lazy는 <img>, <iframe> 등에 적용할 수 있는데 중요하지 않은 리소스로 분류해서 필요할 때만 로드하기때문에 속도만 늦춰질 뿐 지표 점수에는 도움이 되지 않는다.
        - fadeIn ease 10s 등과 같은 애니메이션은 최대 콘텐츠풀 페인트를 늦어지게 만든다.
        - 클라이언트 대신 서버에서 미리 빌드된 채로 오는 것이 좋다.
        - 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하고 그외에 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용해서 관리하는 것이 좋다.

## 12.4 최초 입력 지연(FID)

- 최초 입력 지연이란?
    
    : 최초의 입력 하나에 대한 웹사이트의 반응성을 측정하는 지표
    
    : 정의
    
    <aside>
    📗 사용자가 페이지와 처음 상호 작용할 때 (예: 링크를 클릭하거나 버튼을 탭하거나 사용자 지정 JavaScript 기반 컨트롤을 사용할때)부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정합니다.
    
    </aside>
    
    ⇒ 사용자가 얼마나 빠르게 웹페이지와의 상호작용에 대한 응답을 받을 수 있는지를 측정하는 지표
    
- 구글에서 정의하는 사용자 경험
    - Response : 사용자의 입력에 대한 반응 속도. 50ms 미만으로 이벤트를 처리할 것 ⇒ 최초 입력 지연
    - Animation : 애니메이션의 각 프레임을 10ms 이하로 생성할 것
    - Idle : 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
    - Load : 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

## 12.4.3 예제

- 최초 사용자 입력 후 지연이 발생하는 웹사이트의 성능을 분석한 예제
    
    ![KakaoTalk_Photo_2024-02-28-13-47-15.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/1181b033-3c4a-4189-bfb3-9694c3cd0107/KakaoTalk_Photo_2024-02-28-13-47-15.jpeg)
    
    예제 설명
    
    - 2000ms 경에 클릭이 발생했지만
    - 실제 클릭에 따른 이벤트는 2600ms 경에 시작됐다.
        
        클릭 이벤트가 발생하기 전부터 메인 스레드가 무언가 다른 작업을 하고 있었기 때문에 이것이 끝나고 실행이 될 수 있었던 것이다.
        
    - 즉, 클릭 이벤트가 발생한 시점부터 실제 함수 호출이 있기까지 500ms나 걸렸다. ⇒ 최초 입력 지연

## 12.4.4 기준 점수

![image (2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/553697d6-c2ea-4fa9-a729-412ad0e91453/image_(2).png)

최초 입력 지연에서 해당 지표가 100ms 이내로 응답이 오면 좋은 점수, 300ms 이내로 응답이 오면 보통, 그 이상은 나쁨으로 판단된다.

## 12.4.5 개선 방안

최초 입력 지연을 개선하려면 최초 입력 지연에 가장 큰 영향을 미치는 메인 스레드에 이벤트를 실행할 여유를 줘야한다. 

- 실행에 오래 걸리는 긴 작업(long task : 크롬의 경우 50ms 이상 걸리는 작업)을 분리한다.
    - 꼭 웹페이지에서 처리해야하는 작업이 아니라면 서버로 옮겨서 처리해서 브라우저의 메인 스레드를 오래 점유하지 않게 한다.
    - 꼭 웹페이지에서 처리해야하는 작업이라면 여러개로 분리해서 작업한다. 예를 들면 사용자의 액션으로 인해 노출되는 당장의 로딩에 필요하지 않은 리소스는 리액트의 Suspense와 lazy 또는 Next.js의 dynamic을 이용해 나중에 불러오게 한다.
- 자바스크립트 코드를 최소화한다.
    - 현대의 번들링 도구를 통해 어느 정도 필요 없는 코드를 제거해주지만 경우에 따라 웹페이지를 불러오는 데 사용되지 않는 필요없는 코드가 존재할 수 있다. 이러한 코드들은 지연 로딩 기법 등 우선순위를 낮춰서 불러오는 것이 좋다.
        
        ⇒ 개발자 도구 → Coverage 에서 확인 가능
        
        ![스크린샷 2024-02-28 오후 2.11.00.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/89ee1017-ce9e-42a9-a144-88407a565449/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.11.00.png)
        
        ![스크린샷 2024-02-28 오후 2.15.01.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/74aa8ae7-da30-43fa-9354-694bae396fb1/3364f5c7-5c5e-4cdb-a07b-231a107adc16/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-02-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.15.01.png)
        
    - 폴리필을 넣기 전에 아래 두가지를 확인해본다.
        - 폴리필(polyfill) : 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드로 크기가 기하급수적으로 커지게 되는 단점이 있다.
        - 폴리필이 필요한 환경인가?
            
            인터넷 익스플로러 11과 같은 구형 브라우저 환경을 지원하지 않기로 결심했다면 폴리필을 집어 넣을 필요가 없다.
            
        - 꼭 필요한 폴리필인가?
            
            애플리케이션에서 사용되는 곳이 거의 없다면 폴리필보다 저수준 자바스크립트 코드를 사용하는 것이 코드 크기를 줄이는데 도움이 된다. 
            
- 타사 자바스크립트 코드 실행의 지연
    
    Google Analyics나 Firebase와 같이 웹페이지의 통계 집계를 위해 제 3자가 만든 타사 스크립트 코드의 실행으로 인해 메인 스레드가 잠시 점유되고 사용자에게 안좋은 반응성을 제공한다면 지연 불러오기를 하는 것이 좋다.
    
    - defer
        - HTML 파싱 등의 메인 스레드 작업을 방해하지 않고 병렬로 다운로드 된다.
        - 다운로드가 완료됐다해도 페이지가 완전히 로딩된 이후에 맨 마지막에 실행된다.
    - async
        - 다른 리소스와 함께 병렬로 다운로드 된다.
        - 다운로드가 완료되면 바로 실행된다.