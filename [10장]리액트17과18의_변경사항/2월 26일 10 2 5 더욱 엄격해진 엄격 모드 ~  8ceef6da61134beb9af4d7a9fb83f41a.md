# 2월 26일 10.2.5 더욱 엄격해진 엄격 모드 ~ 11.1. 라우팅(701p~727p)

# 10.2.5 더욱 엄격해진 엄격 모드

## 리액트의 엄격 모드

- 리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는 데 도움이 되는 컴포넌트
- Fragement, Suspense처럼 컴포넌트 형태로 선언해서 사용할 수 있다.

```jsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'

const root = createRoot(document.getElementById('root'))

root.render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

- 엄격 모드에서 수행하는 모드는 모두 개발자 모드에서만 작동하고, 프로덕션 모드에서는 작동하지 않는다.

## 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고

- 리액트 클래스형 컴포넌트에서 사용되는 생명주기 메서드 중 componentWillMount, componentWillReceiveProps, componentWillUpdate는 더 이상 사용할 수 없게 됐다.
- 세 메서드는 16.3 버전부터 UNSAFE_가 붙게 됐고, 이후 16 버전에서는 세 메서드 외의 생명주기 메서드를 사용하면 경고 로그가 기록
- 17버전부터는 UNSAFE_가 붙은 메서드만 남고 나머지는 전부 삭제됐다.
- UNSAFE_가 붙은 생명주기 메서드를 사용하면서 엄격 모드를 켜게 된다면 다음과 같은 로그를 확인할 수 있다.

```jsx
class UnsafeClassComponent extends Component {
  componentWillMount() {
    console.log('componentWillMount')
  }

  render() {
    return <>안녕하세요?</>
  }
}
```

![Untitled](2%E1%84%8B%E1%85%AF%E1%86%AF%2026%E1%84%8B%E1%85%B5%E1%86%AF%2010%202%205%20%E1%84%83%E1%85%A5%E1%84%8B%E1%85%AE%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A7%E1%86%A8%E1%84%92%E1%85%A2%E1%84%8C%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A7%E1%86%A8%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%B3%20~%20%208ceef6da61134beb9af4d7a9fb83f41a/Untitled.png)

## 문자열 ref 사용 금지

- 과거 리액트에는 레거시 문자열 ref라 해서 createRef가 없어도 컴포넌트 내부에서 문자열로 ref를 생성하고, 이를 사용해 DOM 노드를 참조하는 것이 가능했다.

```jsx
class UnsafeClassComponent extends Component {
	componentDidMount() {
		// 'refs' is deprecated.
		// <input type="text" />
		console.log(this.refs.myInput);
	}

	render() {
		return (
			<div>
				<input type="text" ref="myInput" />
			</div>
		)
	}
}
```

- render()에 있는 ref를 보면 단순히 myInput이라는 문자열로 ref에 할당한 것을 볼 수 있으며, 이를 토대로 refs를 바탕으로 DOM에 접근할 수 있다는 것을 알 수 있다.
    
    ![Untitled](2%E1%84%8B%E1%85%AF%E1%86%AF%2026%E1%84%8B%E1%85%B5%E1%86%AF%2010%202%205%20%E1%84%83%E1%85%A5%E1%84%8B%E1%85%AE%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A7%E1%86%A8%E1%84%92%E1%85%A2%E1%84%8C%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A7%E1%86%A8%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%B3%20~%20%208ceef6da61134beb9af4d7a9fb83f41a/Untitled%201.png)
    

### 리액트 팀이 언급한 문자열 ref의 문제

- 문자열로 값을 주는 것은 여러 컴포넌트에 걸쳐 사용될 수 있으므로 충돌의 여지가 있다.
- 앞의 코드에서도 볼 수 있듯이 단순히 문자열로만 존재하기 때문에 실제로 어떤 ref에서 참조되고 있는지 파악하기 어렵다.
- 리액트가 계속해서 현재 렌더링되고 있는 컴포넌트의 ref의 값을 추적해야 하기 때문에 성능 이슈가 있다.

## findDOMNode에 대한 경고 출력

- findDOMNode는 클래스형 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져올 수 있는, 현재는 사용하는 것이 권장되지 않는 메서드

```jsx
class UnsafeClassComponent extends Component {
	componentDidMount() {
		const node = ReactDOM.findDOMNode(this)
		if (node) {
			;(node).style.color = 'red';
		}
	}

	render() {
		return <div>UnsafeClassComponent</div>
	}
}
```

- ReactDOM에서 제공하는 findDOMNode() 메서드를 활용해 클래스형 컴포넌트의 요소에 직접 접근해 해당 DOM 요소의 스타일을 수정

### 리액트 팀이 언급한 findDOMNode의 문제

- findDOMNode를 사용하면 부모가 특정 자식만 별도로 렌더링하는 것이 가능해진다. 이는 리액트가 추구하는 트리 추상화 구조를 무너뜨린다.

```jsx
class ChildComponent extends React.Component {
  render() {
    return <div>UnsafeClassComponent</div>
  }
}

class ParentComponent extends Component {
  handleClick = () => {
    const childNode = ReactDOM.findDOMNode(this.refs.child)
    if (childNode) {
      ;(childNode as HTMLDivElement).style.backgroundColor = 'red'
    }
  }

  render() {
    return (
      <div>
        <ChildComponent ref="child" />
        <button onClick={this.handleClick}>Change Color</button>
      </div>
    )
  }
}
```

- ParentComponent에서 handleClick을 수행하면 자식 컴포넌트의 style이 변경되는 것을 확인할 수 있다. 이는 자식 컴포넌트의 렌더링을 위해서는 부모 컴포넌트의 렌더링이 일어나야 한다는 리액트의 추상화를 무너뜨린다.
- findDOMNode는 항상 첫 번째 자식을 반환하는데, 이는 Fragement를 사용할 때 어색해진다는 문제점이 있었다.

```jsx
class UnsafeClassComponent extends Component {
	componentDidMount() {
		const node = ReactDOM.findDOMNode(this)
		// <div>UnsafeClassComponent1</div> ???
		console.log(node)
	}

	render() {
		return (
			<>
				<div>UnsafeClassComponent1</div>
				<div>UnsafeClassComponent2</div>
				<div>UnsafeClassComponent3</div>
				<div>UnsafeClassComponent4</div>
			</>
		)
	}
}
```

- 마지막으로, findDOMNode는 일회성 API라는 특징 때문에 자식 컴포넌트가 특정 시점에서 다른 노드를 렌더링할 경우 이러한 변경 사항을 추적할 수 없다는 문제점이 있었다. 위와 같은 내용을 종합하면 findDOMNode는 ‘항상 변하지 않는 단일 노드를 반환하는 정적인 컴포넌트’에만 정상적으로 작동하는 반쪽짜리 메서드였다.
- 따라서 문자열 ref와 마찬가지로 findDOMNode는 createRef, useRef를 사용하는 방향으로 전환되어 지원 중단됐다.

## 구 Context API 사용 시 발생하는 경고

- childCotextTypes와 getChildContext를 사용하는 구 리액트 Context API를 사용하면 엄격 모드에서는 에러를 출력한다.

## 예상치 못한 부작용(side-effects) 검사

- 리액트 엄격 모드 내부에서는 다음 내용을 의도적으로 이중으로 호출한다.
    - 클래스형 컴포넌트의 constructor, render, shouldComponentUpdate, getDerivedStateFromProps
    - 클래스형 컴포넌트의 setState의 첫 번째 인수
    - 함수형 컴포넌트의 body
    - useState, useMemo, useReducer에 전달되는 함수

```jsx
export default function App() {
	console.log('component body')

	const [number, setNumber] = useState(() => {
		console.log('initialize state')
		return 0
	})

	const handleClick = useCallback(() => {
		setNumber((prev) => prev + 1)
	}, [])

	const tenTimes = useMemo(() => {
		console.log('* 10!')
		return number * 10
	}, [number])

	return <button onClick={handleClick}>{tenTimes} 클릭</button>
}
```

- 위 코드를 실행하면 브라우저 콘솔에서 다음과 같이 기록되는 것을 확인할 수 있다.

![Untitled](2%E1%84%8B%E1%85%AF%E1%86%AF%2026%E1%84%8B%E1%85%B5%E1%86%AF%2010%202%205%20%E1%84%83%E1%85%A5%E1%84%8B%E1%85%AE%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A7%E1%86%A8%E1%84%92%E1%85%A2%E1%84%8C%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A7%E1%86%A8%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%B3%20~%20%208ceef6da61134beb9af4d7a9fb83f41a/Untitled%202.png)

### 알아두기

- 엄격 모드에서 console.log의 작동 방식이 리액트 17과 리액트 18에서 조금씩 다르다.
- 리액트 17은 이러한 작동 방식에 따른 혼선을 방지하기 위해 의도적으로 두 번씩 기록되지 않게 하는 반면, 리액트 18에서는 두 번씩 기록하되 두 번째 기록, 즉 엄격 모드에 의해 실행된 console.log는 회색으로 표시하게끔 바뀌었다.
- 엄격 모드에서도 한 번씩 기록되게 하고 싶다면 리액트 개발자 도구를 설치한 뒤 리액트 개발자 모드에서 **설정 → debugging → hide logs during second render in Strict Mode**를 체크하면 된다.

### 왜 엄격 모드에서는 두 번씩 실행되는 것일까?

- 함수형 프로그래밍의 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정하기 때문이고, 엄격 모드에서는 앞에서 언급한 내용이 실제로 지켜지고 있는지 (항상 순수한 결과물을 내고 있는지) 개발자에게 확인시켜 주기 위해 두 번 실행하게 되는 것이다.

## 리액트 18에서 추가된 엄격 모드

- 향후 리액트에서는 컴포넌트가 마운트 해제된 상태 (컴포넌트가 렌더링 트리에 존재하지 않는 상태)에서도 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정
- 이러한 기능을 향후에 지원하기 위해 엄격 모드의 개발 모드에 새로운 기능 (컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두 번째 마운트에서 이전 상태를 복원하게 된다)을 도입했다.
- 이후에 있을 변경을 위해 StrictMode에서 고의로 useEffect를 두 번 작동시키는 내용을 추가한 것이다.
- useEffect를 사용할 때 반드시 적절한 cleanup 함수를 배치해서 반복 실행될 수 있는 useEffect로부터 최대한 자유로운 컴포넌트를 만드는 것이 좋다.

# 10.2.6 Suspense 기능 강화

- Suspense는 리액트 16.6 버전에서 실험 버전으로 도입된 기능으로, 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능

```jsx
// Sample Component
export default function SampleComponent() {
	return <>동적으로 가져오는 컴포넌트</>
}

// app.tsx
import { Suspense, lazy } from "react"

const DynamicSampleComponent = lazy(() => import('./SampleComponent'))

export default function App() {
	return (
		<Suspense fallback={<>로딩중</>}>
			<DynamicSampleComponent />
		</Suspense>
	)
}
```

## React.lazy와 Suspense

- React.lazy는 컴포넌트를 첫 번째 렌더링 시에 불러오지 않고, 최초 렌더링 이후에 컴포넌트를 지연시켜 불러오는 역할을 한다.
- SampleComponent를 감싸고 있는 Suspense는 React.lazy를 통해 지연시켜 불러온 컴포넌트를 렌더링하는 역할을 한다.
- Suspense는 크게 두 개의 인수를 받는데, 하나는 지연시켜 불러온 컴포넌트를 미처 불러오지 못했을 때 보여주는 fallback을 나타내는 fallback props
- 그리고 children으로는 React.lazy로 선언한 지연 컴포넌트를 받는다.
- 지연 컴포넌트를 로딩하기 전에는 fallback을 보여주고, lazy로 불러온 컴포넌트가 지연 로딩이 완료되면 해당 컴포넌트를 보여주게 된다.
- 이는 상대적으로 중요하지 않은 컴포넌트를 분할해 초기 렌더링 속도를 향상시키는 데 많은 도움을 줬다.

## 리액트 18 이전의 Suspense의 문제점

- 기존의 Suspense는 컴포넌트가 아직 보이기도 전에 useEffect가 실행되는 문제가 존재했다.
- Suspense는 서버에서 사용할 수 없었다.
    - 기존의 서버 사이드 렌더링 구조에서 Suspense를 활용하려면 useMount와 같은 훅을 구현해서 반드시 클라이언트에서만 작동하도록 처리해야 했다.

## 리액트 18 버전에서 정식으로 지원되는 Suspense의 변경된 내용

- 아직 마운트되기 직전임에도 effect가 빠르게 실행되는 문제가 수정됐다.
    - 이제 컴포넌트가 실제로 화면에 노출될 때 effect가 실행된다.
- Suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행된다.
    - 이전에는 컴포넌트 스스로가 Suspense에 의해 현재 보여지고 있는지, 숨겨져 있는지 알 방법이 없었다 그러나 이제 Suspense에 의해 노출이 된다면 useLayoutEffect의 effect(componentDidMount)가, 가려진다면 useLayoutEffect의 cleanUp(componeentWillUnmount)이 정상적으로 실행된다.
- Suspense를 이제 서버에서도 실행할 수 있게 된다.
    - 앞의 예제와 같이 CustomSuspense를 구현하지 않더라도 정상적으로 Suspense를 사용할 수 있다. 서버에서는 일단 fallback 상태의 트리를 클라이언트에 제공하고, 불러올 준비가 된다면 자연스럽게 렌더링된다.
- Suspense 내에 스로틀링이 추가됐다.
    - 화면이 너무 자주 업데이트되어 시각적으로 방해받는 것을 방지하기 위해 리액트는 다음 렌더링을 보여주기 전에 잠시 대기한다. 즉, 중첩된 Suspense의 fallback이 있다면 자동으로 스로틀되어 최대한 자연스럽게 보여주기 위해 노력한다.

- Suspense의 사용이 이전보다 비교적 자연스러워졌지만 여전히 Suspense를 사용할 수 있는 시나리오는 제한적인 편이다.
- 향후에는 프레임워크 없이도 Suspense를 사용할 수 있는 방법이 나올 것으로 보인다.

# 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- 이제 리액트는 리액트를 사용하는 코드에서 다음과 같은 최신 자바스크립트 기능을 사용할 수 있다는 가정하에 배포된다.
    - Promise: 비동기 연산이 종료된 이후에 실패 또는 결괏값을 확인할 수 있는 객체
    - Symbol: 자바스크립트의 새로운 데이터 형식으로, 익명의 객체 속성을 만들 수 있는 특성을 가진 객체
    - Object.assign: 객체의 열거 가능한 모든 속성을 다른 객체로 붙여 넣는 메서드
- 이러한 세 기능을 지원하지 않는 브라우저에서 서비스해야 한다면 이 세 가지 기능을 위한 폴리필을 반드시 추가해야 한다.
- 만약 인터넷 익스플로러 11을 지원해야 한다면 폴리필 설치 및 트랜스파일에 각별히 신경써야한다.

# 10.2.8 그 밖에 알아두면 좋은 변경사항

- 이제 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다. undefined 반환은 null 반환과 동일하게 처리된다.
- 이와 마찬가지로 `<Suspense fallback={undefined}>`도 null과 동일하게 처리된다.
- renderToNodeStream이 지원 중단됐다. 그 대신 renderToPipeableStream을 사용하는 것이 권장된다.

# 10.2.9 정리

- 리액트 18 버전 업의 핵심은 동시성 렌더링
    - 과거의 렌더링 과정은 일시 중지하거나 중간에 렌더링 결과물을 포기할 수 있는 메커니즘이 없었습니다.
    - 그러나 리액트 18에서는 렌더링 중간에 일시 중지하거나 작업을 포기할 수 있는 새로운 메커니즘이 도입되었습니다.
    - 이로 인해 렌더링 과정은 더 복잡해졌지만 UI 일관성은 유지됩니다.
    - 리액트는 동시성 렌더링을 위해 트리 전체가 계산된 후에 DOM 수정을 기다리며 이는 메인 스레드를 차단하지 않고 백그라운드에서 수행됩니다.
- 리액트 18의 변화는 리액트 생태계 내에 있는 라이브러리, 특히 상태를 관리하는 라이브러리에 큰 영향을 미쳤습니다.
    - 외부 라이브러리가 동시성 렌더링을 지원하기 위해서는 새로운 훅인 useSyncExternalStore를 사용해야 합니다.
    - 이러한 변화는 오픈소스 라이브러리 개발자들에게 시간과 노력을 요구합니다.
- 따라서 리액트 18은 앞으로 리액트 생태계에 있어 큰 이정표가 될 것으로 보입니다.
    - 애플리케이션을 개발할 때 동시성 모드를 고려한다면 이를 지원하는 라이브러리를 사용할지 검토해야 합니다.

# 11장 Next.js 13과 리액트 18

- Next.js 버전 13은 가장 큰 변화가 있는 릴리스
- 서버 사이드 렌더링의 구조에 많은 변화가 있는 리액트 18 채택
- 기존에 Next.js의 큰 약점으로 지적되던 레이아웃 지원을 본격적으로 지원하기 시작
- 바벨을 대체할 러스트(Rust) 기반 SWC를 뒤이어 웹팩을 대체할 Turbopack까지 출시

# 11.1 app 디렉터리의 등장

- 공통 헤더와 사이드 바가 대부분의 페이지에 필요한 웹사이트를 개발한다고 가정
- react-router-dom을 사용한다면
    - <Routes>의 외부 영역은 주소가 바뀌더라도 공통 영역으로 남을 것이며, <Routes> 내부만 주소에 맞게 변경될 것이다.
    - 사용하기에 따라서 <Routes>의 외부 영역 같이 해당 주소의 또 다른 영역을 공통으로 꾸미는 등의 작업이 가능하다.
- Next.js에서 이런 구조를 유지하려면
    - 13 버전 이전까지 모든 페이지는 각각의 물리적으로 구별된 파일로 독립돼 있었다.
    - 페이지 공통으로 무언가를 집어 넣을 수 있는 곳은 _document와 _app이 유일하다.
        - *document: 페이지에서 쓰이는 <html>과 <body> 태그를 수정하거나, 서버 사이드 렌더링 시 styled-components 같은 일부 CSS-in-JS 를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용된다. 오직 서버에서만 작동하므로 onClick같이 이벤트 핸들러를 붙이거나 클라이언트 로직을 붙이는 것을 금지하고 있다.*
        - _app: _app은 페이지를 초기화하기 위한 용도로 사용되며, 다음과 같은 작업이 가능하다고 명시돼 있다.
            - 페이지 변경 시에 유지하고 싶은 레이아웃
            - 페이지 변경 시 상태 유지
            - componentDidCatch를 활용한 에러 핸들링
            - 페이지간 추가적인 데이터 삽입
            - global CSS 주입
- 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app 레이아웃이다.

## 11.1.1 라우팅

- 기존에 /pages로 정의하던 라우팅 방식이 /app 디렉터리로 이동했다.
- 파일명으로 라우팅하는 것이 불가능해졌다.

### 라우팅을 정의하는 법

- app 기반 라우팅 시스템은 기존에 /pages를 사용했던 것과 비슷하지만 다음과 같은 약간의 차이가 있다.
    - Next.js 12 이하: /pages/a/b.tsx 또는 /pages/a/b/index.tsx는 모두 동일한 주소로 변환된다. 즉, 파일명이 index라면 이 내용은 무시된다.
    - Next.js 13 app: /app/a/b는 /a/b로 변환되며, 파일명은 무시된다. 폴더명까지만 주소로 변환된다.
- 즉, Next.js 13의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.

### layout.js

- Next.js 13부터는 app 디렉터리 내부의 폴더명이 라우팅이 되며, 이 폴더에 포함될 수 있는 파일명은 몇 가지로 제한돼 있다.
- 그중 하나가 layout.js이다.
    - 이 파일은 페이지의 기본적인 레이아웃을 구성하는 요소다.
    - 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미친다.
    - 루트에는 단 하나의 layout을 만들어 둘 수 있다. 이 layout은 모든 페이지에 영향을 미치는 공통 레이아웃이다.
    - 꼭 공통 레이아웃이 필요하진 않더라도 웹페이지에 필요한 기본 정보만 담아둬도 추분히 유용하다.
    - 페이지 하위에 추가되는 layout은 해당 주소 하위에만 적용된다.
- layout은 주소별 공통 UI를 포함할 수 있을뿐만 아니라 _app과 _document를 대신해 웹페이지를 시작하는 데 필요한 공통 코드를 삽입할 수도 있다.
- layout.js의 또 다른 장점은 _document.jsx에서만 처리할 수 있었던 부자연스러움이 사라졌다는 것이다.
    - 기존에는 애플리케이션의 <html/>이나 <body/>에 무언가 스타일을 추가하는 등의 작업을 하려면 _document.jsx를 사용해야 했을뿐만 아니라 Next.js에서 제공하는 태그를 사용해야만 했다.
    - 그러나 이제 HTML에서 기본으로 제공하는 태그를 추가하고 수정함으로써 별도로 import하는 번거로움이 사라지고 좀 더 자연스럽게 코드를 작성할 수있게 됐다.
- layout에서 주의해야 할 점
    - layout은 app 디렉터리 내붸서는 예약어다. 무조건 layout.{js|jsx|ts|tsx}로 사용해야 하며, 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
    - layout은 children을 props로 받아서 렌더링해야 한다. 레이아웃이므로 당연히 그려야 할 컴포넌트를 외부에서 주입받고 그려야 한다.
    - layout 내부에는 반드시 export default로 내보내는 컴포넌트가 있어야 한다.
    - layout 내부에서도 API 요청과 같은 비동기 작업을 수행할 수 있다.

### page.js

- layout과 마찬가지로 page도 예약어이며, 이전까지 Next.js에서 일반적으로 다뤘던 페이지를 의미한다.
- 다음과 같이 구성돼 있는 page는 앞에서 구성했던 layout을 기반으로 리액트 컴포넌트를 노출하게 된다.

```jsx
export default function BlogPage() {
  return <>여기에 블로그 글</>
}
```

- 이 page가 받는 props는 다음과 같다.
    - params: 옵셔널 값으로, 앞서 설명한 […id]와 같은 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.
    - searchParams: URL에서 ?a=1과 같은 URLSearchParams를 의마한다. 예를 들어 ?a=1&b=2로 접근할 경우 searchParams에는 { a: ‘1’, b: ‘2’ }라는 자바스크립트 객체 값이 오게 된다. 한 가지 주목해야 할 것은 이 값은 layout에서는 제공되지 않는다는 것이다. 그 이유는 layout은 페이지 탐색 중에는 리렌더링을 수해하지 않기 때문이다. 즉, 같은 페이지에서 search parameter만 다르게 라우팅을 시도하는 경우 layout을 리렌더링하는 것은 불필요하기 때문이다. 만약 search parameter에 의존적인 작업을 해야 한다면 반드시 page 내부에서 수행해야 한다.
- page는 다음과 같은 규칙을 가지고 있다.
    - page도 역시 app 디렉터리 내부의 예약어이다. 무조건 page.{js|jsx|ts|tsx}로 사용해야 하며, 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
    - page도 역시 내부에서 반드시 export default로 내보내는 컴포넌트가 있어야 한다.

### error.js

- 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트다.
- error.js를 사용하면 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.
- error 페이지는 에러 정보를 담고 있는 error: Error 객체와 에러 바운더리를 초기화할 reset: () ⇒ void를 props로 받는다.
- 에러 바운더리는 클라이언트에서만 작동하므로 error 컴포넌트도 클라이언트 컴포넌트여야 한다.
- error 컴포넌트는 같은 수준의 layout에서 에러가 발생할 경우 해당 error 컴포넌트로 이동하지 않는다.
    - 만약 layout에서 발생한 에러를 처리하고 싶다면 상위 컴포넌트의 error를 사용하거나, app의 루트 에러 처리를 담당하는 app/global-error.js 페이지를 생성하면 된다.

### not-found.js

- 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.

### loading.js

- 뒤이어 설명할 Supense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.
- “use client” 지시자를 사용해 클라이언트에서 렌더링되게 할 수도 있다.

### route.js

- Next.js 13.4.0에서 app 디렉터리가 정식으로 출시되면서 이전까지 지원하지 못했던 /pages/api에 대한 /app 디렉터리 내부의 지원도 추가됐다.
- /pages/api와 동일하게 /app/api를 기준으로 디렉터리 라우팅을 지원하며, /api에 대해서도 파일명 라우팅이 없어지는 대신 디렉터리가 라우팅 주소를 담당하며 파일명은 route.js로 통일됐다.
- route.js 파일 내부에 REST API의 get, post와 같은 메서드명을 예약어로 선언해 두면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다.
- app/api 외에 다른 곳에서 선언해도 작동한다.
- 라우팅 명칭에 자유도가 생긴 대신, route.ts가 존재하는 폴더 내부에는 page.tsx가 존재할 수 없다. 만약 두 파일이 공존한다면 경고 메시지를 보게 된다.
- route의 함수들이 받을 수 있는 파라미터는 다음과 같다.
    - request: NextRequest 객체이며, fetch의 Request를 확장한 Next.js만의 Request라고 보면 된다. 이 객체에는 API 요청과 관련된 cookie, headers 등뿐만 아니라 nextUrl 같은 주소 객체도 확인할 수 있다.
    - context: params만을 가지고 있는 객체이며, 이 객체는 앞서 파일 기반 라우팅에서 언급한 것과동일한 동적 라우팅 파라미터 객체가 포함돼 있다. 이 객체는 Next.js에서 별도 인터페이스를 제공하지 않으므로 주소의 필요에 따라 원하는 형식으로 선언하면 된다.